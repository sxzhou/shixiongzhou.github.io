---
layout: post
title:  "[译]SEI CERT Oracle Coding Standard for Java - Thread Apis(THI01-J)"
date:   2017-10-30 22:54:11
categories: java
tags: java
author: "sxzhou"
---
原文：https://wiki.sei.cmu.edu/confluence/display/java/THI01-J.+Do+not+invoke+ThreadGroup+methods
## THI01-J. Do not invoke ThreadGroup methods
在Java语言里，每个线程在创建时都会被分配到一个线程组，这些线程组都是java.lang.ThreadGroup的一个实例，如果没有显式地给一个线程组命名，JVM会分配一个默认的线程组，ThreadGroup提供了一系列便利的方法，调用这些方法可以同时作用于该线程组中所有的线程。比如，ThreadGroup.interrupt()方法可以中断线程组中的所有线程。同时，强制的把线程分组，可以避免不同组的线程相互干扰，有助于构建层次化的安全架构[[JavaThreads 2004]](https://wiki.sei.cmu.edu/confluence/display/java/Rule+AA.+References#RuleAA.References-JavaThreads04)。  
虽然线程组对于管理线程很有用，但开发者却很难从中获利，原因在于ThreadGroup提供的很多方法都被废弃了，比如allowThreadSuspension(),resume(),stop(),suspend()，不仅如此，那些没有废弃的方法也没有多大实用价值。更讽刺的是，ThreadGroup提供的少数方法甚至不是线程安全的[[Bloch 2001]](https://wiki.sei.cmu.edu/confluence/display/java/Rule+AA.+References#RuleAA.References-Bloch01)。  
没有废弃但不安全的方法包括：  
* ThreadGroup.activeCount()  
根据Java API[[API 2014]](https://wiki.sei.cmu.edu/confluence/display/java/Rule+AA.+References#RuleAA.References-API14)的描述，这个方法返回当前线程组及其子线程组中活动线程数的估算值，这个方法经常作为遍历一个线程组的先决条件。事实上，线程池中从未启动的那些线程也会被算作活动线程，同时，这个估算值还会受到某些系统线程的影响[[API 2014]](https://wiki.sei.cmu.edu/confluence/display/java/Rule+AA.+References#RuleAA.References-API14)。因此，activeCount()并不能准确反映线程组当前的活动线程数。
* ThreadGroup.enumerate()
根据Java API[[API 2014]](https://wiki.sei.cmu.edu/confluence/display/java/Rule+AA.+References#RuleAA.References-API14)的描述，enumerate()会将当前线程组及其子线程组中的活动线程复制到一个列表返回，这个方法可能会根据activeCount()的估算结果分配数组大小，如果由于估算不准确导致数组太小，那么多出的超出线程就会被忽略。  

使用ThreadGroup提供的方法关闭线程也存在陷阱，因为stop()方法已经废弃了，开发者需要通过其他方式结束一个线程，根据Java Programming Language[[JPL 2006]](https://wiki.sei.cmu.edu/confluence/display/java/Rule+AA.+References#RuleAA.References-JPL06):  
